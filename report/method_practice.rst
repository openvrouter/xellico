
VNFの簡単な性能推定の練習
-------------------------

実際に研究を進める前に, 研究の動機を明確にするために, 一つの練習をしてみよう.
例えば0番ポートから受信したパケットを1番ポートに転送するアプリケーションを
考えて見る. 多くのDPDKアプリケーションでは以下に示す様な手順でパケット処理を行う.

.. code-block:: none

  pkts, n_rx = rx(portid=0, bulk=32);
  for (i=0; i<n_rx; i++) {
    process_packet(packet=pkts[i]);
    tx(portid=1, packet_array=&pkts[i], n_tx=1);
  }

しかし, DPDKでは, TxBufferを用いることにより, 一定にバルクサイズに
到達するまで送信処理を行わない手法が取られる. [DPDKl3fwddoc]_, [DPDKl3fwdsrc]_
その様にVNFを実装した場合, 計算の構造は以下に示すような状態として
考えることが可能である.  これは常にパケットが到着し続けている状態では
以下のコードと上で示したコードの二つが同じ計算を行うと言うことを示している.

.. code-block:: none

  pkts, n_rx = rx(portid=0, bulk=32);
  for (i=0; i<n_rx; i++) {
    process_packet(packet=pkts[i]);
  }
  tx(portid=1, packet_array=&pkts[i], 32);

本研究では, 上記のコードは同じ性能を示すという前提を固定して研究を進める.

このアプリケーションの性能を考えた場合, このアプリケーションはどの様な性能を
発揮するだろうか. 上記のコードの ``rx()`` ``tx()``
は, 一度の実行ごとに, 100 clockの計算時間を必要とし, ``process_packet()``
は, 一度の実行ごとに, 200 clockの計算時間が必要だとしよう.
つまり, 各関数の遅延は以下の数式に従う.

.. math::

  latency_{rx} = 100 [clock] \\
  latency_{tx} = 100 [clock] \\
  latency_{process\_packet} = 200 [clock] \\

この時のアプリケーションの性能は,

.. math::

  latency_{rx} + 32 * latency_{process\_packet} + latency_{tx} \\
    = 100 + 32 * 200 + 100 \\
    = 6600 [clock/32packet]\\
    = 206 [clock/packet]

となる. 3GHzのCPUを用いた場合, 200 clockにかかる時間は, ``66*10^(-9) sec``
すなわち, 66nsec/packetとなる. 10GbEにおける64Byteワイヤーレートは14Mpps,
``約67nsec/packet`` なため, ``66nsec/packet`` なら10GbEの64Bワイヤーレート
を達成できそうである.

汎用の計算機を用いたVNF開発における性能推定の計算は上記の様に行うが,
実際にその様な単純な計算のみで全てことたりるだろうか. 答えはNoである.
例えば ``rx()`` のblukサイズを1とした場合と32とした場合では関数の
RTT(Round Trip Time)に違いが生じるのは明らかであろう.
また, ``rx()``, ``tx()`` 内部ではPCIe NICのデバイスドライバのコードが実行される.
NICにはPCIeを介してアクセスするため, トランザクションはできるだけまとめた方が
効率的かもしれない. また, RSSを利用した場合, NICに対する単位時間のアクセスが
コア数が増える分増加する事も考えられる. NICに対するアクセスが増加した場合,
PCIeのバスを圧迫して性能低下が起きる可能性はあるのか.
そして, これらは全てのNICに共通した性能をだすのだろうか.おそらく,
これらの値はNICの種類によって違いが生じるだろう.

ここまで説明しただけでもわからないことがたくさん出てきた.
本研究ではそれらの疑問を細かいマイクロベンチマークを測ることにより明らかに
していく.

まず, 先ほどの様な (擬似コードの例) DPDKのシンプルなアプリケーションの
関数レイテンシを測る方法を定義し, これを用いてDPDKのAPIの細かい関数遅延,
(RTTともよぶ)を計測する. 次に, これらで求めた値が, RSS等のHW支援機能を
利用した時に性能に変化があるかを検討する. 今回調べるHW支援機能はRSSのみを
対象とするが, 同様の手順で他のHW支援機能も計測することが可能である.
(例えばChecksum計算OffloadやFlow Director等) しかし, パケットのドロップを
伴う場合は, パケット処理のpathが先ほど示したモデルと変わるため, 再検討が
必要である.
